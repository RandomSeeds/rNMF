% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/rnmf.R
\name{rnmf}
\alias{rnmf}
\title{Robust penalized non-negative matrix factorization.}
\usage{
rnmf(A, k = 5, alpha = 0, beta = 0, maxit = 50, tol = 0.001,
  trim = FALSE, ini.W = NULL, ini.H = NULL, ini.zeta = NULL,
  my.seed = NULL, variation = "cell", quiet = FALSE, nreg = 1,
  showprogress = TRUE)
}
\arguments{
\item{A}{a nonnegative numerical matrix. The matrix to be decomposed into WH.}

\item{k}{a nonnegative integer. The lower dimension (number of columns of W).}

\item{alpha}{a nonnegative number. Default = 0. It controls the magnitude of
||W||_2^2.}

\item{beta}{a nonnegative number. Default = 0. It controls the sparsity of H.}

\item{maxit}{a positive integer. Default = 50. Maximum number of iterations.}

\item{tol}{a number between 0 and 1. Default = 0.001. Tolerance for
convergence. We suggest a number smaller than 0.01.}

\item{trim}{a number between 0 and 1. Default = 0. Percentage of contents of
X to be trimmed. rnmf() performs the regular NMF if trim = 0.}

\item{ini.W}{a nonnegative numeric matrix with k columns and the same number
of rows as A. Default = NULL. Initial left matrix W in A ~ WH.}

\item{ini.H}{a nonnegative numeric matrix with k rows and the same number of
columns as A. Default = NULL. Initial right matrix H in A ~ WH. Must have the
same number of columns as A and k rows. ini.H is ignored if ini.W is not NULL.}

\item{ini.zeta}{a logical matrix the same size as A. Default = NULL. Initial
location of outliers (FALSE in ini.zeta). The number of "FALSE" in ini.zeta
must be <=  round(trim * p * n).}

\item{my.seed}{a nonnegative integer. Default = NULL. The random seed for
initialization of W or H. my.seed is ignored if ini.H or ini.W is not NULL.}

\item{variation}{a character string. Default = "cell". Triming variation. The options are: 'cell', 'col', 'row' and 'smooth'.}

\item{quiet}{a logic string. Default = FALSE. If quiet == TRUE the on screen
report after rnmf() is run is suppressed.}

\item{nreg}{a positive integer. Default = 1. Number of runs in the "cell"
variation. Not tested yet. DON'T change its default value. (and don't ask questions).}

\item{showprogress}{a logic string. Default = TRUE. If TRUE show progress
bar during iteration}
}
\value{
An object of class 'rnmf', which is a list of the following items:
\itemize{
\item "W": Left matrix of the decomposition, columns of which are basis
vectors of the low dimension projection.
\item "H": Right matrix of the decomposition, columns of which are low
dimensional encoding of the data.
\item "fit": W \%*\% H.
\item "trimmed": A list of locations of trimmed cells in each iteration
\item "niter": Number of iterations performed.
}
}
\description{
This function performs robust penalized non-negative matrix factorizaion on a
non-negative matrix A to obtain W and H, such that A ~ WH. Here A is a p by n
matrix where columns are observations and rows are variables. W is a p by k,
and H is k by n. Outliers in A are detected and trimmed (by cells, columns or
rows, see "details"). The objective function is
}
\details{
||A - WH||_{trimmed} + alpha * ||W||_2^2 + beta * sum(|H_.j|)^2.

The minimization process is a generalized alternating least square method.
}
\examples{
## Load a clean single simulated tumor image.
data("Tumor")
## Add 5\\\% corruptions.
Tumor.corrupted = Tumor
set.seed(1)
Tumor.corrupted[sample(1:4900, round(0.05 * 4900), replace = FALSE)] = 1
## Do rnmf with different settings
res.rnmf1 = rnmf(A = Tumor.corrupted, trim = FALSE, my.seed = 1)
res.rnmf2 = rnmf(A = Tumor.corrupted, tol = 0.001, trim = 0.06, my.seed = 1)
res.rnmf3 = rnmf(A = Tumor.corrupted, k = 10, beta = 0.1, tol = 0.001, trim = 0.06, my.seed = 1, variation = "smooth")
par(mfrow = c(2,2))
image(Tumor.corrupted, main = "Corrupted")
image(res.rnmf1$fit, main = "rnmf (no trimming) fit")
image(res.rnmf2$fit, main = "rnmf (cell) fit 2")
image(res.rnmf3$fit, main = "rnmf (smooth) fit 3")
}

